<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>節奏練習器</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --primary: #10b981;
            --accent-ui: #f43f5e;
            --text: #f8fafc;
            --focus: #3b82f6;
            --box-size: 80px; 
            --gap: 8px;
            --padding-side: 10px;
            --border-width: 2px;
            
            /* 一個小節的總寬度 = (格子*4) + (間隔*3) + (左右Padding總計) */
            --measure-width: calc((var(--box-size) * 4) + (var(--gap) * 3) + (var(--padding-side) * 2));
        }
        @media (max-width: 768px) {
            :root {
                --box-size: 60px;
            }
        }

        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex; flex-direction: column; height: 100vh; overflow-x: hidden;
        }
        
        .controls {
            padding: 15px 20px; background: var(--panel);
            display: flex; flex-direction: column;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            position: sticky; top: 0; z-index: 100;
            gap: 12px;
        }
        .controls-header {
            display: flex; justify-content: flex-start; align-items: center;
        }
        .actions { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; justify-content: flex-start; }
        .control-group { display: flex; align-items: center; gap: 10px; }
        
        .label-text { font-size: 14px; color: #94a3b8; font-weight: bold; white-space: nowrap; }

        select {
            background: #334155; color: white; border: 1px solid #475569;
            padding: 4px 10px; border-radius: 8px; outline: none; cursor: pointer; font-size: 14px;
            height: 30px;
        }
        
         /* 音符選擇列樣式 */
        .note-selector {
            display: flex; gap: 8px; overflow-x: auto; padding: 6px 0;
            scrollbar-width: thin; scrollbar-color: var(--focus) transparent;
            justify-content: flex-start;
        }
        .note-chip {
            flex: 0 0 auto; background: #334155; border: 1px solid #475569;
            width: 60px; height: 30px; /* 正方形按鈕 */
            border-radius: 8px; cursor: pointer;
            font-size: 11px; font-weight: bold; color: #cbd5e1; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px;
            user-select: none;
        }
        .note-chip.active { background: var(--focus); color: white; border-color: #60a5fa; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3); }
        .note-chip span { font-size: 10px; opacity: 0.8; }

        /* 隨機選項多選樣式 */
        .random-options {
            display: flex; gap: 4px; background: #334155; padding: 3px; border-radius: 8px; border: 1px solid #475569;
        }
        .random-chip {
            border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold;
            color: #94a3b8; transition: all 0.2s; user-select: none; white-space: nowrap;
            height: 20px; width: 20px; padding: 0; display: flex; align-items: center; justify-content: center;
        }
        .random-chip.selected { background: var(--focus); color: white; }

        .btn-play {
            background: var(--primary); color: white; border: none;
            padding: 4px 12px; border-radius: 8px; font-weight: bold;
            cursor: pointer; display: flex; align-items: center; gap: 8px;
            transition: all 0.2s; min-width: 30px; justify-content: center; font-size: 14px;
            height: 30px;
        }
        .btn-play.playing { background: var(--accent-ui); }
        .btn-play.disabled {
            background: #94a3b8; color: #64748b; cursor: not-allowed;
            filter: grayscale(100%);
        }
        .btn-loop { margin-left: 4px; }

        .btn-random {
            background: #6366f1; color: white; border: none;
            padding: 4px 12px; border-radius: 8px; font-weight: bold;
            cursor: pointer; transition: all 0.2s; font-size: 14px;
            height: 30px;
        }

        .main-content {
            flex-grow: 1; display: flex; flex-direction: column;
            align-items: center; padding: 20px 10px;
            overflow-y: auto;
            justify-content: space-between;
        }
        
        .editor-row { 
            display: flex; flex-direction: column; align-items: flex-start; 
            margin-bottom: 40px; width: auto; 
        }
        
        .row-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .row-label { font-weight: bold; color: #94a3b8; font-size: 0.9rem; }
        .editor-row.playing-row .row-label { color: var(--primary); transform: scale(1.05); }

        .editor-strip {
            display: flex;
            flex-wrap: wrap;
            background: #fff; padding: 5px;
            border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            max-width: calc((var(--measure-width) * 4) + (var(--border-width) * 3) + 12px); 
            width: fit-content;
            box-sizing: border-box;
            justify-content: flex-start;
        }

        .measure {
            flex: 0 0 var(--measure-width); 
            display: flex; flex-direction: column; gap: 5px; 
            border-right: var(--border-width) solid #cbd5e1; 
            padding: 10px var(--padding-side);
            box-sizing: border-box;
        }
        
        .measure.measure-last-in-row { border-right: none; }

        .measure-beats { display: flex; gap: var(--gap); justify-content: center; }
        .beat-info { font-size: 10px; color: #94a3b8; text-align: left; margin-bottom: 4px; font-weight: 800; padding-left: 5px; }

        .beat-box {
            width: var(--box-size); height: var(--box-size); background: #f8fafc;
            border: 2px solid #e2e8f0; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.1s; position: relative;
            touch-action: manipulation;
            box-sizing: border-box;
        }
        .beat-box.active { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        .beat-box.playing-now { background: rgba(16, 185, 129, 0.2) !important; border-color: var(--primary) !important; }
        
        canvas { max-width: 100%; max-height: 100%; }

        .btn-remove {
            width: 24px; height: 24px; border-radius: 50%; border: 1px solid var(--accent-ui);
            background: transparent; color: var(--accent-ui); font-size: 0.8rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }

        .btn-add {
            width: 45px; height: 45px; border-radius: 50%; border: 2px dashed #475569;
            background: transparent; color: #475569; font-size: 1.5rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center; margin: 10px 0 30px 0;
        }
        
        .measure-buttons {
            display: flex; flex-direction: row; gap: var(--gap);
            align-items: center;
        }
        
        .btn-add-measure, .btn-remove-measure {
            width: 24px; height: 24px;
            border-radius: 0; border: 2px dashed #475569;
            background: transparent; color: #475569; font-size: 0.8rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; box-sizing: border-box;
        }
        .btn-add-measure:hover {
            background: rgba(71, 85, 105, 0.1); border-color: var(--primary); color: var(--primary);
        }
        .btn-remove-measure:hover {
            background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444;
        }

        #countInOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.7); border-radius: 8px;
            display: none; align-items: center; justify-content: center;
            z-index: 50; color: #fff; font-size: 2.5rem; font-weight: 900;
            pointer-events: none; text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

    <div class="controls">
        <!-- 第一排：標題 -->
        <div class="controls-header">
            <div style="font-size: 1.2rem; font-weight: 800; letter-spacing: 1px;">DRUM BEAT <span style="color:var(--primary)">DEV</span></div>
        </div>
        
        <!-- 第二排：控制項 -->
        <div class="actions">
            <div class="control-group">
                <span class="label-text">音色:</span>
                <select id="soundSelect">
                    <option value="snap">Snap</option>
                    <option value="noise" selected>Noise</option>
                </select>
                <span class="label-text">重音:</span>
                <select id="accentSoundSelect">
                    <option value="snap" selected>Snap</option>
                    <option value="noise">Noise</option>
                </select>
            </div>
            <div class="control-group">
                <div class="random-options" id="randomOptionsContainer">
                    <div class="random-chip selected" data-value="1">1</div>
                    <div class="random-chip" data-value="2">2</div>
                    <div class="random-chip" data-value="3">3</div>
                    <div class="random-chip" data-value="4">4</div>
                    <div class="random-chip" data-value="5">5</div>
                    <div class="random-chip" data-value="6">6</div>
                    <div class="random-chip" data-value="7">7</div>
                    <div class="random-chip" data-value="8">8</div>
                </div>
                <button id="randomFillBtn" class="btn-random">隨機</button>
            </div>
            <div class="control-group">
                <span style="font-size: 15px; white-space: nowrap; font-weight: bold;">BPM: <strong id="bpmValue" style="font-size: 16px;">120</strong></span>
                <input type="range" id="bpmSlider" min="40" max="220" step="5" value="120" style="width: 150px; accent-color: var(--primary); height: 8px;">
            </div>
            <button id="playBtn" class="btn-play">播放</button>
            <button id="loopBtn" class="btn-play btn-loop">循環</button>
            <label style="display: flex; align-items: center; gap: 5px; margin-left: 5px; cursor: pointer;">
                <input type="checkbox" id="metronomeCheckbox" style="width: 18px; height: 18px; cursor: pointer;">
                <span style="font-size: 14px; color: #475569; font-weight: 500;">拍子提示</span>
            </label>
        </div>
        
        <!-- 第三排：音符選擇器 -->
        <div class="note-selector" id="noteSelector">
            <div class="note-chip active" data-id="11">4分</div>
            <div class="note-chip" data-id="12">4分休止</div>
            <div class="note-chip" data-id="21">8分</div>
            <div class="note-chip" data-id="31">16分單點</div>
            <div class="note-chip" data-id="41">16分雙點</div>
            <div class="note-chip" data-id="51">16分三點</div>
            <div class="note-chip" data-id="55">16分四點</div>
            <div class="note-chip" data-id="61">16分單重音</div>
            <div class="note-chip" data-id="71">16分雙重音</div>
            <div class="note-chip" data-id="81">16分三重音</div>
            <div class="note-chip" data-id="85">16分全重音</div>
        </div>
    </div>

    <div class="main-content">
        <div style="flex: 1; width: 100%; display: flex; flex-direction: column; align-items: center;">
            <div id="rowsContainer" style="width: 100%; display: flex; flex-direction: column; align-items: center;"></div>
            <button class="btn-add" id="addRowBtn">+</button>
        </div>
        
        <!-- 底部控制列：JSON 顯示區域 -->
        <div class="controls" style="width: 100%; max-width: 100%; margin-top: auto; box-sizing: border-box;">
            <div style="width: 100%; max-width: 100%; box-sizing: border-box;">
                <label style="display: block; font-size: 12px; color: #94a3b8; font-weight: bold; margin-bottom: 5px;">鼓譜音符ID (JSON格式):</label>
                <textarea id="scoreJsonDisplay" readonly style="width: 100%; max-width: 100%; min-height: 80px; padding: 8px; background: #1e293b; color: #cbd5e1; border: 1px solid #475569; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 11px; resize: vertical; box-sizing: border-box; white-space: pre-wrap; word-wrap: break-word;"></textarea>
            </div>
        </div>
    </div>

    <script>
        const workerCode = `let t=null;self.onmessage=(e)=>{if(e.data==="start")t=setInterval(()=>postMessage("tick"),10);else if(e.data==="stop")clearInterval(t);};`;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const timerWorker = new Worker(URL.createObjectURL(blob));

        let audioCtx = null, isPlaying = false, nextNoteTime = 0.0, currentGlobalStep = 0;
        let isCountingIn = false, countInStep = 0;
        let isLoopMode = false; // 循環播放模式
        let isMetronomeEnabled = false; // 拍子提示開關
        let playbackStartTime = 0.0; // 播放開始的絕對時間（用於誤差校正）
        let playbackStartStep = 0; // 播放開始時的步數（用於誤差校正）

        const rowsContainer = document.getElementById('rowsContainer'), addRowBtn = document.getElementById('addRowBtn');
        const playBtn = document.getElementById('playBtn'), loopBtn = document.getElementById('loopBtn');
        const bpmSlider = document.getElementById('bpmSlider'), bpmValue = document.getElementById('bpmValue');
        const soundSelect = document.getElementById('soundSelect'), accentSoundSelect = document.getElementById('accentSoundSelect');
        const randomOptionsContainer = document.getElementById('randomOptionsContainer'), randomFillBtn = document.getElementById('randomFillBtn');
        const metronomeCheckbox = document.getElementById('metronomeCheckbox');
        const scoreJsonDisplay = document.getElementById('scoreJsonDisplay');
        const beatsPerMeasure = 4; // 每個小節 4 拍
        const maxRows = 16; // 最大句段數
        const maxMeasures = 16; // 每個句段最大小節數 
        
        const SERIES_MAP = {
            1: [11], 2: [21, 22, 23], 3: [31, 32, 33, 34], 4: [41, 42, 43, 44, 45, 46],
            5: [51, 52, 53, 54, 55], 6: [61, 62, 63, 64], 7: [71, 72, 73, 74, 75, 76], 8: [81, 82, 83, 84, 85]
        };

        let focusState = { row: 0, beat: 0 };
        let scoreData = [new Array(beatsPerMeasure).fill(0)]; // 預設一個小節（4拍）
        let selectedNoteId = null; // 當前選中的音符 ID

        // 定義循環輸入規則
        const NOTE_CYCLES = {
            21: [21, 22, 23],
            31: [31, 32, 33, 34],
            41: [41, 42, 43, 44, 45, 46],
            51: [51, 52, 53, 54],
            61: [61, 62, 63, 64],
            71: [71, 72, 73, 74, 75, 76],
            81: [81, 82, 83, 84]
        };

        function initApp() {
            renderRows();
            initRandomToggles();
            initNoteSelector();
            updateScoreJson(); // 初始化時顯示JSON
            bpmSlider.oninput = (e) => { bpmValue.textContent = e.target.value; };
            addRowBtn.onclick = () => { if (scoreData.length < maxRows) { scoreData.push(new Array(beatsPerMeasure).fill(0)); renderRows(); } };
            playBtn.onclick = () => { 
                console.log('[DEBUG] 播放按鈕點擊');
                isLoopMode = false; 
                console.log('[DEBUG] 設置 isLoopMode = false');
                togglePlayback(); 
            };
            loopBtn.onclick = () => { 
                console.log('[DEBUG] 循環按鈕點擊');
                isLoopMode = true; 
                console.log('[DEBUG] 設置 isLoopMode = true');
                togglePlayback(); 
            };
            randomFillBtn.onclick = handleRandomFill;
            metronomeCheckbox.onchange = (e) => { isMetronomeEnabled = e.target.checked; };
            
            // 监听窗口大小改变，重新计算小节线
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    updateMeasureBorders();
                }, 100);
            });
            
            // 监听页面可见性变化：切换到后台时停止播放
            document.addEventListener('visibilitychange', () => {
                console.log('[DEBUG] 頁面可見性變化:', {
                    hidden: document.hidden,
                    isPlaying: isPlaying,
                    audioCtxState: audioCtx ? audioCtx.state : 'null',
                    isLoopMode: isLoopMode
                });
                if (document.hidden && isPlaying) {
                    console.log('[DEBUG] 切換到背景，停止播放');
                    stopPlayback();
                }
            });
        }

        function updateButtonStates() {
            console.log('[DEBUG] updateButtonStates 調用:', {
                isPlaying: isPlaying,
                isLoopMode: isLoopMode
            });
            // 只有在播放时才设置互斥状态
            if (isPlaying) {
                if (isLoopMode) {
                    playBtn.classList.add('disabled');
                    loopBtn.classList.remove('disabled');
                    console.log('[DEBUG] 播放中（循環模式），播放按鈕灰階，循環按鈕亮');
                } else {
                    playBtn.classList.remove('disabled');
                    loopBtn.classList.add('disabled');
                    console.log('[DEBUG] 播放中（普通模式），播放按鈕亮，循環按鈕灰階');
                }
            } else {
                // 停止时，两个按钮都亮
                playBtn.classList.remove('disabled');
                loopBtn.classList.remove('disabled');
                console.log('[DEBUG] 停止狀態，兩個按鈕都亮');
            }
        }

        function initNoteSelector() {
            const noteSelector = document.getElementById('noteSelector');
            noteSelector.querySelectorAll('.note-chip').forEach(chip => {
                chip.onclick = () => {
                    // 移除所有 active 狀態
                    noteSelector.querySelectorAll('.note-chip').forEach(c => c.classList.remove('active'));
                    // 設置當前選中的 chip 為 active
                    chip.classList.add('active');
                    // 保存選中的音符 ID
                    selectedNoteId = parseInt(chip.getAttribute('data-id'));
                };
            });
        }

        function initRandomToggles() {
            randomOptionsContainer.querySelectorAll('.random-chip').forEach(chip => { chip.onclick = () => { chip.classList.toggle('selected'); }; });
        }

        function handleRandomFill() {
            const selectedSeries = Array.from(randomOptionsContainer.querySelectorAll('.random-chip.selected')).map(chip => chip.getAttribute('data-value'));
            if (selectedSeries.length === 0) return;
            let pool = []; selectedSeries.forEach(s => { pool = pool.concat(SERIES_MAP[s]); });
            scoreData.forEach((rowData) => { for (let i = 0; i < rowData.length; i++) { rowData[i] = pool[Math.floor(Math.random() * pool.length)]; } });
            renderRows();
        }

        async function togglePlayback() {
            console.log('[DEBUG] togglePlayback 開始:', {
                audioCtxExists: !!audioCtx,
                audioCtxState: audioCtx ? audioCtx.state : 'null',
                isPlaying: isPlaying,
                isLoopMode: isLoopMode
            });
            
            if (!audioCtx) {
                console.log('[DEBUG] 創建新的 AudioContext');
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // 確保 AudioContext 處於運行狀態
            console.log('[DEBUG] AudioContext 當前狀態:', audioCtx.state);
            if (audioCtx.state === 'suspended') {
                console.log('[DEBUG] AudioContext 被暫停，嘗試恢復...');
                await audioCtx.resume();
                console.log('[DEBUG] resume() 調用後狀態:', audioCtx.state);
            }
            // 如果 AudioContext 狀態不是 'running'，等待它恢復
            if (audioCtx.state !== 'running') {
                console.log('[DEBUG] AudioContext 狀態不是 running，等待狀態變化...');
                try {
                    await new Promise((resolve, reject) => {
                        // 设置超时，避免无限等待
                        const timeout = setTimeout(() => {
                            console.error('[ERROR] AudioContext 恢復超時');
                            reject(new Error('AudioContext 恢復超時'));
                        }, 3000);
                        
                        const checkState = () => {
                            console.log('[DEBUG] 檢查 AudioContext 狀態:', audioCtx.state);
                            if (audioCtx.state === 'running') {
                                clearTimeout(timeout);
                                console.log('[DEBUG] AudioContext 已恢復為 running');
                                resolve();
                            } else if (audioCtx.state === 'closed') {
                                clearTimeout(timeout);
                                console.error('[ERROR] AudioContext 已關閉');
                                reject(new Error('AudioContext 已關閉'));
                            } else {
                                console.log('[DEBUG] 等待 AudioContext 狀態變化...');
                                audioCtx.addEventListener('statechange', checkState, { once: true });
                            }
                        };
                        checkState();
                    });
                } catch (error) {
                    console.error('[ERROR] AudioContext 恢復失敗:', error);
                    // 如果恢复失败，重新创建 AudioContext
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('[DEBUG] 重新創建 AudioContext，狀態:', audioCtx.state);
                }
            }
            
            console.log('[DEBUG] AudioContext 最終狀態:', audioCtx.state);
            console.log('[DEBUG] 當前 isPlaying:', isPlaying);
            
            if (!isPlaying) {
                console.log('[DEBUG] 開始播放，設置狀態...');
                isPlaying = true; 
                isCountingIn = true; 
                countInStep = 0; 
                currentGlobalStep = 0; 
                // 記錄播放開始的絕對時間和步數，用於避免累積誤差
                playbackStartTime = audioCtx.currentTime + 0.05;
                playbackStartStep = 0;
                // 減少初始延遲，使用更小的值以減少首次播放延遲
                nextNoteTime = playbackStartTime;
                console.log('[DEBUG] 播放狀態設置完成:', {
                    isPlaying: isPlaying,
                    isLoopMode: isLoopMode,
                    playbackStartTime: playbackStartTime,
                    nextNoteTime: nextNoteTime,
                    audioCtxCurrentTime: audioCtx.currentTime
                });
                const overlay = document.getElementById('countInOverlay');
                if (overlay) overlay.style.display = 'flex';
                console.log('[DEBUG] 發送 timerWorker start 訊息');
                timerWorker.postMessage("start");
                if (isLoopMode) {
                    loopBtn.classList.add('playing'); loopBtn.textContent = "停止";
                    console.log('[DEBUG] 循環模式，更新循環按鈕');
                } else {
                    playBtn.classList.add('playing'); playBtn.textContent = "停止";
                    console.log('[DEBUG] 普通模式，更新播放按鈕');
                }
                updateButtonStates(); // 更新按钮状态，使另一个按钮灰阶
                console.log('[DEBUG] 播放已啟動');
            } else { 
                console.log('[DEBUG] 正在播放，調用 stopPlayback()');
                // 用户手动停止，重置循环模式状态
                isLoopMode = false;
                stopPlayback(); 
            }
        }

        function stopPlayback() {
            console.log('[DEBUG] stopPlayback 開始:', {
                isPlaying: isPlaying,
                isLoopMode: isLoopMode,
                audioCtxState: audioCtx ? audioCtx.state : 'null'
            });
            
            // 先设置 isPlaying 为 false，防止后续的调度继续执行
            isPlaying = false; 
            isCountingIn = false;
            // 注意：不重置 isLoopMode，因为用户可能希望保持循环模式设置
            // 只有在用户手动停止时才重置 isLoopMode（在 togglePlayback 中处理）
            
            // 重置時間相關變量
            currentGlobalStep = 0;
            countInStep = 0;
            nextNoteTime = 0.0;
            playbackStartTime = 0.0;
            playbackStartStep = 0;
            
            console.log('[DEBUG] 發送 timerWorker stop 訊息');
            timerWorker.postMessage("stop");
            playBtn.classList.remove('playing'); playBtn.textContent = "播放";
            loopBtn.classList.remove('playing'); loopBtn.textContent = "循環";
            const overlay = document.getElementById('countInOverlay');
            if (overlay) overlay.style.display = 'none';
            clearPlaybackUI(); resetRowStyles();
            updateButtonStates();
            
            console.log('[DEBUG] stopPlayback 完成，狀態已重置:', {
                isPlaying: isPlaying,
                isLoopMode: isLoopMode,
                currentGlobalStep: currentGlobalStep
            });
        }

        function clearPlaybackUI() { document.querySelectorAll('.beat-box').forEach(el => el.classList.remove('playing-now')); }
        function resetRowStyles() { document.querySelectorAll('.editor-row').forEach(row => { row.classList.remove('playing-row'); }); }

        timerWorker.onmessage = (e) => {
            if (e.data === "tick") {
                if (!isPlaying) return;
                
                // 检查 audioCtx 是否存在且可用
                if (!audioCtx || audioCtx.state === 'closed') {
                    console.warn('[WARN] timerWorker: audioCtx 不可用，停止播放');
                    stopPlayback();
                    return;
                }
                
                // 如果 AudioContext 处于 suspended 状态，尝试恢复
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(err => {
                        console.error('[ERROR] timerWorker: 無法恢復 AudioContext:', err);
                        stopPlayback();
                    });
                    return; // 暂时跳过，等待恢复
                }
                
                const bpm = parseInt(bpmSlider.value), beatDur = 60.0 / bpm;
                // 增加調度提前時間到 0.2 秒，確保高 BPM 時也能及時調度
                const scheduleAheadTime = 0.2;
                
                // 誤差校正：定期檢查誤差累積量，當誤差過大時根據步數校正回正確時間
                if (!isCountingIn && currentGlobalStep % 100 === 0 && currentGlobalStep > 0) {
                    // 計算預期時間：基於初始時間和步數
                    const expectedTime = playbackStartTime + (currentGlobalStep - playbackStartStep) * beatDur;
                    // 計算實際時間
                    const actualTime = audioCtx.currentTime;
                    // 計算誤差累積量
                    const error = actualTime - expectedTime;
                    // 如果誤差超過10ms，根據步數校正回正確時間
                    if (Math.abs(error) > 0.01) {
                        playbackStartTime = actualTime;
                        playbackStartStep = currentGlobalStep;
                        // 重新計算 nextNoteTime，校正誤差（基於新的基準點和下一步的步數）
                        // 注意：currentGlobalStep 是下一步要處理的步數，所以不需要加1
                        nextNoteTime = playbackStartTime;
                    }
                }
                
                while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                    // 在循环内部检查 isPlaying，防止停止播放后继续执行
                    if (!isPlaying) {
                        console.log('[DEBUG] timerWorker: 檢測到播放已停止，退出調度循環');
                        break;
                    }
                    
                    if (isCountingIn) {
                        if (countInStep < 4) { 
                            scheduleCountIn(countInStep, nextNoteTime); 
                            countInStep++; 
                            nextNoteTime += beatDur;
                        } else { 
                            // 倒數結束：countInStep === 4 時，nextNoteTime 已經是倒數"1"之後的一拍時間
                            // 第一拍音符應該在這個時間播放
                            isCountingIn = false; 
                            updateCountInUI(null); 
                            // 倒數結束後，初始化誤差校正的基準點
                            // 第一拍音符的時間就是當前的 nextNoteTime
                            playbackStartTime = nextNoteTime;
                            playbackStartStep = currentGlobalStep;
                            // 直接使用當前的 nextNoteTime 播放第一拍音符
                            processSequenceStep(beatDur); 
                            // 检查播放是否已停止（可能在 processSequenceStep 中调用了 stopPlayback）
                            if (!isPlaying) {
                                console.log('[DEBUG] timerWorker: 播放已停止（在 processSequenceStep 中）');
                                break;
                            }
                            nextNoteTime += beatDur;
                        }
                    } else { 
                        processSequenceStep(beatDur); 
                        // 检查播放是否已停止（可能在 processSequenceStep 中调用了 stopPlayback）
                        if (!isPlaying) {
                            console.log('[DEBUG] timerWorker: 播放已停止（在 processSequenceStep 中）');
                            break;
                        }
                        // 時間計算一直延續，無論是否發生循環重置，都繼續累加
                        // 循環重置只影響音符指標（currentGlobalStep），不影響時間計算
                        nextNoteTime += beatDur;
                    }
                }
            }
        };

        function processSequenceStep(dur) {
            // 計算總步數：所有句段的所有拍數總和
            const totalStepsInSequence = scoreData.reduce((sum, rowData) => sum + rowData.length, 0);
            
            // 如果是循環模式且到達末尾，重置到開始
            if (currentGlobalStep >= totalStepsInSequence) {
                if (isLoopMode) {
                    // 循環模式：時間計算一直延續，只是音符指標指回開頭
                    // 更新誤差校正的基準點：使用當前的 nextNoteTime 作為新一輪循環的基準
                    // 這樣可以保持時間的連續性，同時重置誤差校正的基準
                    playbackStartTime = nextNoteTime;
                    playbackStartStep = 0;
                    // 只重置音符指標，時間繼續延續
                    currentGlobalStep = 0;
                    // nextNoteTime 不改變，繼續在 while 循環中累加，保持時間連續性
                    console.log('[DEBUG] 循環模式：重置音符指標到開始，時間繼續延續', {
                        playbackStartTime: playbackStartTime,
                        nextNoteTime: nextNoteTime,
                        currentGlobalStep: currentGlobalStep,
                        currentTime: audioCtx.currentTime
                    });
                    // 不返回，繼續處理第一拍（currentGlobalStep = 0）
                } else {
                    // 非循環模式：播放完畢，停止播放
                    console.log('[DEBUG] 播放完畢（非循環模式），停止播放');
                    stopPlayback(); 
                    return;
                }
            }
            
            // 找到當前步數對應的句段和拍數
            let stepCount = 0;
            let r = 0, b = 0;
            for (let i = 0; i < scoreData.length; i++) {
                if (currentGlobalStep < stepCount + scoreData[i].length) {
                    r = i;
                    b = currentGlobalStep - stepCount;
                    break;
                }
                stepCount += scoreData[i].length;
            }
            
            scheduleStep(r, b, nextNoteTime, dur); currentGlobalStep++;
        }

        function scheduleCountIn(step, time) {
            // 检查 audioCtx 是否存在且可用
            if (!audioCtx || audioCtx.state === 'closed') {
                console.warn('[WARN] scheduleCountIn: audioCtx 不可用');
                return;
            }
            
            // 如果 AudioContext 处于 suspended 状态，尝试恢复
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(err => {
                    console.error('[ERROR] scheduleCountIn: 無法恢復 AudioContext:', err);
                    if (isPlaying) stopPlayback();
                });
                return; // 暂时跳过，等待恢复
            }
            
            // 如果时间太早（已经过去超过 0.1 秒），跳过调度
            const timeDiff = time - audioCtx.currentTime;
            if (timeDiff < -0.1) {
                console.warn('[WARN] scheduleCountIn: 時間已過，跳過調度', { time, currentTime: audioCtx.currentTime, diff: timeDiff });
                return;
            }
            
            try {
                const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time);
                gain.gain.setValueAtTime(0.4, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(time); osc.stop(time + 0.1);
                const countText = (4 - step).toString();
                const delay = (time - audioCtx.currentTime) * 1000;
                setTimeout(() => { if (isCountingIn && isPlaying) updateCountInUI(countText); }, Math.max(0, delay));
            } catch (error) {
                console.error('[ERROR] scheduleCountIn 錯誤:', error);
                // 如果出现错误，停止播放以避免持续崩溃
                if (isPlaying) stopPlayback();
            }
        }

        function updateCountInUI(text) {
            const overlay = document.getElementById('countInOverlay'); if (!overlay) return;
            if (text === null) overlay.style.display = 'none'; else { overlay.style.display = 'flex'; overlay.textContent = text; }
        }

        function playSound(time, freq, volume = 0.3, soundType = 'snap', isAccent = false) {
            // 检查 audioCtx 是否存在且可用
            if (!audioCtx || audioCtx.state === 'closed') {
                console.warn('[WARN] playSound: audioCtx 不可用');
                return;
            }
            
            // 如果 AudioContext 处于 suspended 状态，尝试恢复
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(err => {
                    console.error('[ERROR] playSound: 無法恢復 AudioContext:', err);
                    if (isPlaying) stopPlayback();
                });
                return; // 暂时跳过，等待恢复
            }
            
            // 如果时间太早（已经过去超过 0.1 秒），跳过调度
            const timeDiff = time - audioCtx.currentTime;
            if (timeDiff < -0.1) {
                console.warn('[WARN] playSound: 時間已過，跳過調度', { time, currentTime: audioCtx.currentTime, diff: timeDiff });
                return;
            }
            
            // 確保時間不會是過去時間，避免延遲
            const scheduleTime = Math.max(time, audioCtx.currentTime);
            const finalVol = isAccent ? volume * 1.6 : volume, finalFreq = isAccent ? freq * 1.2 : freq;
            
            try {
                if (soundType === 'noise') {
                    const bufferSize = audioCtx.sampleRate * 0.1, buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate), data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = buffer;
                    const gainNode = audioCtx.createGain(), noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'highpass'; noiseFilter.frequency.value = finalFreq * 3;
                    noiseSource.connect(noiseFilter); noiseFilter.connect(gainNode);
                    gainNode.gain.setValueAtTime(finalVol * 0.4, scheduleTime); gainNode.gain.exponentialRampToValueAtTime(0.001, scheduleTime + 0.05);
                    noiseSource.start(scheduleTime); noiseSource.stop(scheduleTime + 0.079); gainNode.connect(audioCtx.destination); return;
                }
                const osc = audioCtx.createOscillator(), gainNode = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(finalFreq * 2, scheduleTime);
                gainNode.gain.setValueAtTime(finalVol * 0.5, scheduleTime); gainNode.gain.exponentialRampToValueAtTime(0.001, scheduleTime + 0.05);
                osc.connect(gainNode); gainNode.connect(audioCtx.destination); osc.start(scheduleTime); osc.stop(scheduleTime + 0.079);
            } catch (error) {
                console.error('[ERROR] playSound 錯誤:', error);
                // 如果出现错误，停止播放以避免持续崩溃
                if (isPlaying) stopPlayback();
            }
        }

        function playMetronomeTick(time) {
            // 检查 audioCtx 是否存在且可用
            if (!audioCtx || audioCtx.state === 'closed') {
                console.warn('[WARN] playMetronomeTick: audioCtx 不可用');
                return;
            }
            
            // 如果 AudioContext 处于 suspended 状态，尝试恢复
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(err => {
                    console.error('[ERROR] playMetronomeTick: 無法恢復 AudioContext:', err);
                });
                return; // 暂时跳过，等待恢复
            }
            
            // 如果时间太早（已经过去超过 0.1 秒），跳过调度
            const timeDiff = time - audioCtx.currentTime;
            if (timeDiff < -0.1) {
                console.warn('[WARN] playMetronomeTick: 時間已過，跳過調度', { time, currentTime: audioCtx.currentTime, diff: timeDiff });
                return;
            }
            
            // 播放叮聲作為拍子提示（類似倒數的聲音）
            try {
                const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time);
                gain.gain.setValueAtTime(0.3, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.08);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(time); osc.stop(time + 0.08);
            } catch (error) {
                console.error('[ERROR] playMetronomeTick 錯誤:', error);
            }
        }

        // 檢查音符類型是否在第一個位置（p16[0]）有聲音
        function hasSoundAtFirstPosition(type) {
            if (type === 0 || type === 12) return false; // 無聲
            if (type === 11) return true; // 4分音符，在第一個位置
            if (type === 21 || type === 23) return true; // 8分音符，在第一個位置
            if (type === 22) return false; // 8分音符，在第二個位置
            if (type === 31) return true; // 16分單點，在第一個位置
            if (type >= 32 && type <= 34) return false; // 16分單點，在其他位置
            // 16分雙點
            if (type === 41 || type === 44 || type === 45) return true; // [0,1] 或 [0,3] 或 [0,2]
            if (type === 42 || type === 43 || type === 46) return false; // 不在第一個位置
            // 16分三點
            if (type === 51 || type === 52 || type === 53 || type === 55) return true; // 包含第一個位置
            if (type === 54) return false; // [1,2,3]，不在第一個位置
            // 16分單重音、雙重音、三重音：所有位置都有聲音，所以第一個位置也有
            if (type >= 61 && type <= 85) return true;
            return false;
        }

        function scheduleStep(r, b, time, dur) {
            const type = scoreData[r][b]; updateUI(r, b, time);
            
            // 如果啟用了拍子提示，且是小節第一拍，播放叮聲
            const shouldPlayMetronome = isMetronomeEnabled && (b % beatsPerMeasure === 0);
            const skipFirstPosition = shouldPlayMetronome && hasSoundAtFirstPosition(type);
            
            if (shouldPlayMetronome) {
                playMetronomeTick(time);
            }
            
            if (type === 0 || type === 12) return;
            const baseFreq = 220, p16 = [0, 0.25, 0.5, 0.75], cS = soundSelect.value, cAS = accentSoundSelect.value;
            const play = (t, isAcc = false) => { playSound(t, baseFreq, 0.3, isAcc ? cAS : cS, isAcc); };
            
            if (type === 11) {
                if (!skipFirstPosition) play(time);
            } else if (type === 21) {
                if (!skipFirstPosition) play(time);
            } else if (type === 22) {
                play(time + dur * 0.5); // 後半拍正常播放
            } else if (type === 23) {
                if (!skipFirstPosition) play(time); // 前半拍：如果第一個位置有聲音且啟用拍子提示，則跳過
                play(time + dur * 0.5); // 後半拍正常播放
            } else if (type >= 31 && type <= 34) {
                if (!skipFirstPosition || type !== 31) play(time + dur * p16[type - 31]);
            } else if (type >= 41 && type <= 46) {
                const m = { 41:[0,1], 42:[1,2], 43:[2,3], 44:[0,3], 45:[0,2], 46:[1,3] };
                m[type].forEach(idx => {
                    // 如果跳過第一個位置且當前是第一個位置，則跳過
                    if (!(skipFirstPosition && idx === 0)) {
                        play(time + dur * p16[idx]);
                    }
                });
            } else if (type >= 51 && type <= 55) {
                const m = { 51:[0,2,3], 52:[0,1,2], 53:[0,1,3], 54:[1,2,3], 55:[0,1,2,3] };
                m[type].forEach(idx => {
                    if (!(skipFirstPosition && idx === 0)) {
                        play(time + dur * p16[idx]);
                    }
                });
            } else if (type >= 61 && type <= 64) {
                const aI = type - 61;
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, i === aI);
                    }
                });
            } else if (type >= 71 && type <= 76) {
                const m = { 71:[0,1], 72:[1,2], 73:[2,3], 74:[0,3], 75:[0,2], 76:[1,3] };
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, m[type].includes(i));
                    }
                });
            } else if (type >= 81 && type <= 85) {
                const m = { 81:[0,2,3], 82:[0,1,2], 83:[0,1,3], 84:[1,2,3], 85:[0,1,2,3] };
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, m[type].includes(i));
                    }
                });
            }
        }

        function updateUI(r, b, time) {
            // 检查 audioCtx 是否存在且可用
            if (!audioCtx || audioCtx.state === 'closed') {
                return;
            }
            
            // 确保时间不会太早，使用当前音频上下文时间作为基准
            const scheduleTime = Math.max(time, audioCtx.currentTime);
            const delay = (scheduleTime - audioCtx.currentTime) * 1000;
            
            // 使用 requestAnimationFrame 来确保更精确的时间同步
            if (delay <= 0) {
                // 如果时间已过或非常接近，立即更新
                if (!isPlaying || isCountingIn) return;
                document.querySelectorAll('.editor-row').forEach((row, idx) => { if (idx === r) row.classList.add('playing-row'); else row.classList.remove('playing-row'); });
                clearPlaybackUI(); 
                const el = document.getElementById(`beat-${r}-${b}`); 
                if (el) el.classList.add('playing-now');
            } else {
                // 使用 setTimeout，但确保延迟计算准确
                setTimeout(() => {
                    if (!isPlaying || isCountingIn) return;
                    document.querySelectorAll('.editor-row').forEach((row, idx) => { if (idx === r) row.classList.add('playing-row'); else row.classList.remove('playing-row'); });
                    clearPlaybackUI(); 
                    const el = document.getElementById(`beat-${r}-${b}`); 
                    if (el) el.classList.add('playing-now');
                }, Math.max(0, Math.round(delay)));
            }
        }

        function drawNoteHead(ctx, x, y, color = '#1e293b') { ctx.save(); ctx.fillStyle = color; ctx.translate(x, y); ctx.rotate(-0.25); ctx.beginPath(); ctx.ellipse(0, 0, 5, 3.5, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawStem(ctx, x, yT, yB, color = '#1e293b', w = 1.5) { ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = w; ctx.beginPath(); ctx.moveTo(x, yT); ctx.lineTo(x, yB); ctx.stroke(); ctx.restore(); }
        function drawQuarterRest(ctx, x, y) { ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x - 4, y - 10); ctx.lineTo(x + 2, y - 4); ctx.lineTo(x - 4, y + 2); ctx.lineTo(x + 2, y + 8); ctx.bezierCurveTo(x + 2, y + 11, x - 1, y + 12, x - 4, y + 10); ctx.stroke(); ctx.restore(); }
        function drawAccent(ctx, x, y) { ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x - 4, y - 3); ctx.lineTo(x + 3, y); ctx.lineTo(x - 4, y + 3); ctx.stroke(); ctx.restore(); }

        function drawNote(ctx, type) {
            ctx.clearRect(0, 0, 80, 80); if (type === 0) return;
            const bY = 55, sT = 22, center = 40, sSB = 38;
            if (type === 11) { drawNoteHead(ctx, center - 4, bY); drawStem(ctx, center + 0.5, sT, bY); }
            else if (type === 12) { drawQuarterRest(ctx, center, 40); }
            else if (type >= 21 && type <= 23) { 
                const p1 = 25, p2 = 55; ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(p1+4.5, sT+2); ctx.lineTo(p2+4.5, sT+2); ctx.stroke(); ctx.restore();
                if (type === 21 || type === 23) { drawNoteHead(ctx, p1, bY); drawStem(ctx, p1+4.5, sT, bY, '#1e293b', 2); } else { drawStem(ctx, p1+4.5, sT, sSB, '#1e293b', 1.5); }
                if (type === 22 || type === 23) { drawNoteHead(ctx, p2, bY); drawStem(ctx, p2+4.5, sT, bY, '#1e293b', 2); } else { drawStem(ctx, p2+4.5, sT, sSB, '#1e293b', 1.5); }
            } else if (type >= 31) { 
                const pos = [18, 32, 46, 60]; let act = [], acc = [];
                if (type >= 31 && type <= 34) act = [type - 31];
                else if (type === 41) act = [0, 1]; else if (type === 42) act = [1, 2]; else if (type === 43) act = [2, 3]; else if (type === 44) act = [0, 3]; else if (type === 45) act = [0, 2]; else if (type === 46) act = [1, 3];
                else if (type === 51) act = [0, 2, 3]; else if (type === 52) act = [0, 1, 2]; else if (type === 53) act = [0, 1, 3]; else if (type === 54) act = [1, 2, 3]; else if (type === 55) act = [0, 1, 2, 3];
                else if (type >= 61 && type <= 64) { act = [0, 1, 2, 3]; acc = [type - 61]; }
                else if (type >= 71 && type <= 76) { act = [0, 1, 2, 3]; if (type === 71) acc = [0, 1]; else if (type === 72) acc = [1, 2]; else if (type === 73) acc = [2, 3]; else if (type === 74) acc = [0, 3]; else if (type === 75) acc = [0, 2]; else if (type === 76) acc = [1, 3]; }
                else if (type >= 81 && type <= 85) { act = [0, 1, 2, 3]; if (type === 81) acc = [0, 2, 3]; else if (type === 82) acc = [0, 1, 2]; else if (type === 83) acc = [0, 1, 3]; else if (type === 84) acc = [1, 2, 3]; else if (type === 85) acc = [0, 1, 2, 3]; }
                ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(pos[0]+4.5, sT); ctx.lineTo(pos[3]+4.5, sT); ctx.stroke(); ctx.beginPath(); ctx.moveTo(pos[0]+4.5, sT+6); ctx.lineTo(pos[3]+4.5, sT+6); ctx.stroke(); ctx.restore();
                pos.forEach((x, i) => { if (act.includes(i)) { drawNoteHead(ctx, x, bY); drawStem(ctx, x+4.5, sT, bY, '#1e293b', 1.5); if (acc.includes(i)) drawAccent(ctx, x + 4, sT - 8); } else { drawStem(ctx, x+4.5, sT, sSB, '#1e293b', 1.2); } });
            }
        }

        function updateScoreJson() {
            // 將scoreData轉換為JSON格式並顯示（單行字符串，自動換行）
            if (scoreJsonDisplay) {
                scoreJsonDisplay.value = JSON.stringify(scoreData);
            }
        }

        function renderRows() {
            rowsContainer.innerHTML = '';
            scoreData.forEach((rowData, rI) => {
                const row = document.createElement('div'); row.className = 'editor-row';
                const head = document.createElement('div'); head.className = 'row-header';
                const lab = document.createElement('div'); lab.className = 'row-label'; lab.textContent = `句段 ${rI+1}`;
                head.appendChild(lab);
                
                // 添加增加/刪除小節的按鈕容器到 row-header
                const measureButtonsContainer = document.createElement('div');
                measureButtonsContainer.className = 'measure-buttons';
                
                // 添加增加小節的按鈕
                if (rowData.length < maxMeasures * beatsPerMeasure) {
                    const addMeasureBtn = document.createElement('button');
                    addMeasureBtn.className = 'btn-add-measure';
                    addMeasureBtn.textContent = '+';
                    addMeasureBtn.title = '增加小節';
                    addMeasureBtn.onclick = () => {
                        // 增加一個小節（4拍）
                        for (let i = 0; i < beatsPerMeasure; i++) {
                            scoreData[rI].push(0);
                        }
                        renderRows();
                    };
                    measureButtonsContainer.appendChild(addMeasureBtn);
                }
                
                // 添加刪除小節的按鈕（當小節數大於1時顯示）
                const currentMeasureCount = Math.ceil(rowData.length / beatsPerMeasure);
                if (currentMeasureCount > 1) {
                    const removeMeasureBtn = document.createElement('button');
                    removeMeasureBtn.className = 'btn-remove-measure';
                    removeMeasureBtn.textContent = '−';
                    removeMeasureBtn.title = '刪除小節';
                    removeMeasureBtn.onclick = () => {
                        // 刪除最後一個小節（4拍）
                        const removeCount = Math.min(beatsPerMeasure, rowData.length);
                        scoreData[rI].splice(rowData.length - removeCount, removeCount);
                        // 確保至少保留一個小節
                        if (scoreData[rI].length === 0) {
                            for (let i = 0; i < beatsPerMeasure; i++) {
                                scoreData[rI].push(0);
                            }
                        }
                        // 調整焦點位置，確保不超出範圍
                        if (focusState.row === rI && focusState.beat >= scoreData[rI].length) {
                            focusState.beat = Math.max(0, scoreData[rI].length - 1);
                        }
                        renderRows();
                    };
                    measureButtonsContainer.appendChild(removeMeasureBtn);
                }
                
                if (measureButtonsContainer.children.length > 0) {
                    head.appendChild(measureButtonsContainer);
                }
                
                if (scoreData.length > 1) { const rm = document.createElement('button'); rm.className = 'btn-remove'; rm.textContent = '×'; rm.onclick = () => { scoreData.splice(rI,1); renderRows(); }; head.appendChild(rm); }
                row.appendChild(head);
                const strip = document.createElement('div'); strip.className = 'editor-strip';
                
                // 動態渲染小節，根據 rowData 的長度
                const measureCount = Math.ceil(rowData.length / beatsPerMeasure);
                for (let m = 0; m < measureCount; m++) {
                    const meas = document.createElement('div'); meas.className = 'measure';
                    const inf = document.createElement('div'); inf.className = 'beat-info'; inf.textContent = `小節 ${m+1}`; meas.appendChild(inf);
                    const bR = document.createElement('div'); bR.className = 'measure-beats';
                    for (let b = 0; b < beatsPerMeasure; b++) {
                        const bIdx = m * beatsPerMeasure + b;
                        const box = document.createElement('div');
                        box.className = `beat-box`; if(rI===focusState.row && bIdx===focusState.beat) box.classList.add('active');
                        box.id = `beat-${rI}-${bIdx}`;
                        if (bIdx < rowData.length) {
                            // 如果數據存在，顯示音符
                            if (rI === 0 && bIdx === 0) { const over = document.createElement('div'); over.id = 'countInOverlay'; box.appendChild(over); }
                            const can = document.createElement('canvas'); can.width = 80; can.height = 80;
                            box.appendChild(can); box.onclick = () => setFocus(rI, bIdx); 
                            requestAnimationFrame(() => drawNote(can.getContext('2d'), rowData[bIdx]));
                        } else {
                            // 如果數據不存在，顯示空白格子（用於最後一個不完整的小節）
                            box.style.opacity = '0.3';
                            box.style.pointerEvents = 'none';
                        }
                        bR.appendChild(box);
                    }
                    meas.appendChild(bR); strip.appendChild(meas);
                }
                
                row.appendChild(strip); rowsContainer.appendChild(row);
            });
            updateScoreJson(); // 更新JSON顯示
            
            // 在所有DOM渲染完成后，标记每行最后一个小节
            requestAnimationFrame(() => {
                updateMeasureBorders();
            });
        }
        
        function updateMeasureBorders() {
            // 遍历所有句段
            document.querySelectorAll('.editor-strip').forEach(strip => {
                const measures = Array.from(strip.querySelectorAll('.measure'));
                if (measures.length === 0) return;
                
                // 移除所有现有的标记
                measures.forEach(m => m.classList.remove('measure-last-in-row'));
                
                // 计算每行最后一个小节
                for (let i = 0; i < measures.length; i++) {
                    const currentMeasure = measures[i];
                    const nextMeasure = measures[i + 1];
                    
                    // 获取当前小节和下一个小节的顶部位置
                    const currentTop = currentMeasure.offsetTop;
                    const nextTop = nextMeasure ? nextMeasure.offsetTop : null;
                    
                    // 如果没有下一个小节，或者下一个小节在不同的行（顶部位置不同），则当前小节是行尾
                    if (!nextMeasure || nextTop !== currentTop) {
                        currentMeasure.classList.add('measure-last-in-row');
                    }
                }
            });
        }

        function setFocus(r, b) { 
            r = (r + scoreData.length) % scoreData.length; 
            if (!scoreData[r]) return;
            const maxBeat = scoreData[r].length;
            b = (b + maxBeat) % maxBeat; 
            
            // 如果有選中的音符，執行循環輸入
            if (selectedNoteId !== null) {
                const currentValue = scoreData[r][b];
                const cycle = NOTE_CYCLES[selectedNoteId];
                
                if (cycle) {
                    // 如果當前值在循環範圍內，找到下一個值
                    const currentIndex = cycle.indexOf(currentValue);
                    if (currentIndex >= 0) {
                        // 循環到下一個值
                        const nextIndex = (currentIndex + 1) % cycle.length;
                        scoreData[r][b] = cycle[nextIndex];
                    } else {
                        // 如果當前值不在循環範圍內，設置為循環的第一個值
                        scoreData[r][b] = cycle[0];
                    }
                } else {
                    // 如果沒有循環規則，直接設置為選中的值
                    scoreData[r][b] = selectedNoteId;
                }
            }
            
            focusState = { row: r, beat: b }; 
            renderRows(); 
        }

        window.onkeydown = (e) => {
            if (e.code === 'Space') { e.preventDefault(); togglePlayback(); return; }
            if (!scoreData[focusState.row] || focusState.beat >= scoreData[focusState.row].length) return;
            const cur = scoreData[focusState.row][focusState.beat]; let val = -1;
            if (e.key === '1') val = (cur === 11) ? 12 : 11;
            else if (e.key === '2') { if (cur === 21) val = 22; else if (cur === 22) val = 23; else val = 21; }
            else if (e.key === '3') { if (cur >= 31 && cur < 34) val = cur + 1; else val = 31; }
            else if (e.key === '4') { if (cur >= 41 && cur < 46) val = cur + 1; else val = 41; }
            else if (e.key === '5') { if (cur >= 51 && cur < 55) val = cur + 1; else val = 51; }
            else if (e.key === '6') { if (cur >= 61 && cur < 64) val = cur + 1; else val = 61; }
            else if (e.key === '7') { if (cur >= 71 && cur < 76) val = cur + 1; else val = 71; }
            else if (e.key === '8') { if (cur >= 81 && cur < 85) val = cur + 1; else val = 81; }
            else if (e.key === 'Escape' || e.key === 'Backspace') val = 0;
            if (val !== -1) { scoreData[focusState.row][focusState.beat] = val; renderRows(); }
            if (e.key === 'ArrowRight') { e.preventDefault(); setFocus(focusState.row, focusState.beat + 1); }
            if (e.key === 'ArrowLeft') { e.preventDefault(); setFocus(focusState.row, focusState.beat - 1); }
            if (e.key === 'ArrowUp') { e.preventDefault(); setFocus(focusState.row - 1, focusState.beat); }
            if (e.key === 'ArrowDown') { e.preventDefault(); setFocus(focusState.row + 1, focusState.beat); }
            // 確保焦點不超出當前句段的範圍
            if (scoreData[focusState.row] && focusState.beat >= scoreData[focusState.row].length) {
                focusState.beat = scoreData[focusState.row].length - 1;
                renderRows();
            }
        };

        initApp();
    </script>
</body>
</html>