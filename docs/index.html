<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>節奏練習器</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --primary: #10b981;
            --accent-ui: #f43f5e;
            --text: #f8fafc;
            --focus: #3b82f6;
            --box-size: 80px; 
            --gap: 8px;
            --padding-side: 10px;
            --border-width: 2px;
            
            /* 一個小節的總寬度 = (格子*4) + (間隔*3) + (左右Padding總計) */
            --measure-width: calc((var(--box-size) * 4) + (var(--gap) * 3) + (var(--padding-side) * 2));
        }
        @media (max-width: 768px) {
            :root {
                --box-size: 60px;
            }
        }

        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex; flex-direction: column; height: 100vh; overflow-x: hidden;
        }
        
        .controls {
            padding: 15px 20px; background: var(--panel);
            display: flex; flex-direction: column;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            position: sticky; top: 0; z-index: 100;
            gap: 12px;
        }
        .controls-header {
            display: flex; justify-content: flex-start; align-items: center;
        }
        .actions { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: flex-start; }
        .control-group { display: flex; align-items: center; gap: 10px; }
        
        .label-text { font-size: 14px; color: #94a3b8; font-weight: bold; white-space: nowrap; }

        select {
            background: #334155; color: white; border: 1px solid #475569;
            padding: 10px 14px; border-radius: 8px; outline: none; cursor: pointer; font-size: 16px;
            min-height: 42px;
        }
        
         /* 音符選擇列樣式 */
        .note-selector {
            display: flex; gap: 8px; overflow-x: auto; padding: 6px 0;
            scrollbar-width: thin; scrollbar-color: var(--focus) transparent;
            justify-content: flex-start;
        }
        .note-chip {
            flex: 0 0 auto; background: #334155; border: 1px solid #475569;
            width: 60px; height: 60px; /* 正方形按鈕 */
            border-radius: 8px; cursor: pointer;
            font-size: 13px; font-weight: bold; color: #cbd5e1; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px;
            user-select: none;
        }
        .note-chip.active { background: var(--focus); color: white; border-color: #60a5fa; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3); }
        .note-chip span { font-size: 10px; opacity: 0.8; }

        /* 隨機選項多選樣式 */
        .random-options {
            display: flex; gap: 4px; background: #334155; padding: 5px; border-radius: 8px; border: 1px solid #475569;
        }
        .random-chip {
            padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;
            color: #94a3b8; transition: all 0.2s; user-select: none; white-space: nowrap;
            min-height: 32px; width: 32px; padding: 0; display: flex; align-items: center; justify-content: center;
        }
        .random-chip.selected { background: var(--focus); color: white; }

        .btn-play {
            background: var(--primary); color: white; border: none;
            padding: 12px 24px; border-radius: 8px; font-weight: bold;
            cursor: pointer; display: flex; align-items: center; gap: 8px;
            transition: all 0.2s; min-width: 100px; justify-content: center; font-size: 16px;
            min-height: 42px;
        }
        .btn-play.playing { background: var(--accent-ui); }
        .btn-play.disabled {
            background: #94a3b8; color: #64748b; cursor: not-allowed;
            filter: grayscale(100%);
        }
        .btn-loop { margin-left: 10px; }

        .btn-random {
            background: #6366f1; color: white; border: none;
            padding: 10px 18px; border-radius: 8px; font-weight: bold;
            cursor: pointer; transition: all 0.2s; font-size: 15px;
            min-height: 42px;
        }

        .main-content {
            flex-grow: 1; display: flex; flex-direction: column;
            align-items: center; padding: 20px 10px;
            overflow-y: auto;
        }
        
        .editor-row { 
            display: flex; flex-direction: column; align-items: flex-start; 
            margin-bottom: 40px; width: auto; 
        }
        
        .row-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .row-label { font-weight: bold; color: #94a3b8; font-size: 0.9rem; }
        .editor-row.playing-row .row-label { color: var(--primary); transform: scale(1.05); }

        .editor-strip {
            display: flex;
            flex-wrap: wrap;
            background: #fff; padding: 5px;
            border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            max-width: calc((var(--measure-width) * 4) + (var(--border-width) * 3) + 12px); 
            width: fit-content;
            box-sizing: border-box;
            justify-content: flex-start;
        }

        .measure {
            flex: 0 0 var(--measure-width); 
            display: flex; flex-direction: column; gap: 5px; 
            border-right: var(--border-width) solid #cbd5e1; 
            padding: 10px var(--padding-side);
            box-sizing: border-box;
        }
        
        .measure:nth-child(4n), .measure:last-child { border-right: none; }

        .measure-beats { display: flex; gap: var(--gap); justify-content: center; }
        .beat-info { font-size: 10px; color: #94a3b8; text-align: left; margin-bottom: 4px; font-weight: 800; padding-left: 5px; }

        .beat-box {
            width: var(--box-size); height: var(--box-size); background: #f8fafc;
            border: 2px solid #e2e8f0; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.1s; position: relative;
            touch-action: manipulation;
            box-sizing: border-box;
        }
        .beat-box.active { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        .beat-box.playing-now { background: rgba(16, 185, 129, 0.2) !important; border-color: var(--primary) !important; }
        
        canvas { max-width: 100%; max-height: 100%; }

        .btn-remove {
            width: 24px; height: 24px; border-radius: 50%; border: 1px solid var(--accent-ui);
            background: transparent; color: var(--accent-ui); font-size: 0.8rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }

        .btn-add {
            width: 45px; height: 45px; border-radius: 50%; border: 2px dashed #475569;
            background: transparent; color: #475569; font-size: 1.5rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center; margin: 10px 0 30px 0;
        }
        
        .measure-buttons {
            display: flex; flex-direction: row; gap: var(--gap);
            align-items: center;
        }
        
        .btn-add-measure, .btn-remove-measure {
            width: 24px; height: 24px;
            border-radius: 0; border: 2px dashed #475569;
            background: transparent; color: #475569; font-size: 0.8rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; box-sizing: border-box;
        }
        .btn-add-measure:hover {
            background: rgba(71, 85, 105, 0.1); border-color: var(--primary); color: var(--primary);
        }
        .btn-remove-measure:hover {
            background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444;
        }

        #countInOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.7); border-radius: 8px;
            display: none; align-items: center; justify-content: center;
            z-index: 50; color: #fff; font-size: 2.5rem; font-weight: 900;
            pointer-events: none; text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

    <div class="controls">
        <!-- 第一排：標題 -->
        <div class="controls-header">
            <div style="font-size: 1.2rem; font-weight: 800; letter-spacing: 1px;">DRUM BEAT <span style="color:var(--primary)">DEV</span></div>
        </div>
        
        <!-- 第二排：控制項 -->
        <div class="actions">
            <div class="control-group">
                <span class="label-text">音色:</span>
                <select id="soundSelect">
                    <option value="snap">Snap</option>
                    <option value="noise" selected>Noise</option>
                </select>
                <span class="label-text">重音:</span>
                <select id="accentSoundSelect">
                    <option value="snap" selected>Snap</option>
                    <option value="noise">Noise</option>
                </select>
            </div>
            <div class="control-group">
                <div class="random-options" id="randomOptionsContainer">
                    <div class="random-chip selected" data-value="1">1</div>
                    <div class="random-chip" data-value="2">2</div>
                    <div class="random-chip" data-value="3">3</div>
                    <div class="random-chip" data-value="4">4</div>
                    <div class="random-chip" data-value="5">5</div>
                    <div class="random-chip" data-value="6">6</div>
                    <div class="random-chip" data-value="7">7</div>
                    <div class="random-chip" data-value="8">8</div>
                </div>
                <button id="randomFillBtn" class="btn-random">隨機</button>
            </div>
            <div class="control-group">
                <span style="font-size: 15px; white-space: nowrap; font-weight: bold;">BPM: <strong id="bpmValue" style="font-size: 16px;">120</strong></span>
                <input type="range" id="bpmSlider" min="40" max="220" step="5" value="120" style="width: 150px; accent-color: var(--primary); height: 8px;">
            </div>
            <button id="playBtn" class="btn-play">播放</button>
            <button id="loopBtn" class="btn-play btn-loop">循環</button>
            <label style="display: flex; align-items: center; gap: 5px; margin-left: 10px; cursor: pointer;">
                <input type="checkbox" id="metronomeCheckbox" style="width: 18px; height: 18px; cursor: pointer;">
                <span style="font-size: 14px; color: #475569; font-weight: 500;">拍子提示</span>
            </label>
        </div>
        
        <!-- 第三排：音符選擇器 -->
        <div class="note-selector" id="noteSelector">
            <div class="note-chip active" data-id="11">4分</div>
            <div class="note-chip" data-id="12">4分休止</div>
            <div class="note-chip" data-id="21">8分</div>
            <div class="note-chip" data-id="31">16分單點</div>
            <div class="note-chip" data-id="41">16分雙點</div>
            <div class="note-chip" data-id="51">16分三點</div>
            <div class="note-chip" data-id="55">16分四點</div>
            <div class="note-chip" data-id="61">16分單重音</div>
            <div class="note-chip" data-id="71">16分雙重音</div>
            <div class="note-chip" data-id="81">16分三重音</div>
            <div class="note-chip" data-id="85">16分全重音</div>
        </div>
    </div>

    <div class="main-content">
        <div id="rowsContainer" style="width: 100%; display: flex; flex-direction: column; align-items: center;"></div>
        <button class="btn-add" id="addRowBtn">+</button>
    </div>

    <script>
        const workerCode = `let t=null;self.onmessage=(e)=>{if(e.data==="start")t=setInterval(()=>postMessage("tick"),10);else if(e.data==="stop")clearInterval(t);};`;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const timerWorker = new Worker(URL.createObjectURL(blob));

        let audioCtx = null, isPlaying = false, nextNoteTime = 0.0, currentGlobalStep = 0;
        let isCountingIn = false, countInStep = 0;
        let isLoopMode = false; // 循環播放模式
        let isMetronomeEnabled = false; // 拍子提示開關

        const rowsContainer = document.getElementById('rowsContainer'), addRowBtn = document.getElementById('addRowBtn');
        const playBtn = document.getElementById('playBtn'), loopBtn = document.getElementById('loopBtn');
        const bpmSlider = document.getElementById('bpmSlider'), bpmValue = document.getElementById('bpmValue');
        const soundSelect = document.getElementById('soundSelect'), accentSoundSelect = document.getElementById('accentSoundSelect');
        const randomOptionsContainer = document.getElementById('randomOptionsContainer'), randomFillBtn = document.getElementById('randomFillBtn');
        const metronomeCheckbox = document.getElementById('metronomeCheckbox');
        const beatsPerMeasure = 4; // 每個小節 4 拍
        const maxRows = 16; // 最大句段數
        const maxMeasures = 16; // 每個句段最大小節數 
        
        const SERIES_MAP = {
            1: [11], 2: [21, 22, 23], 3: [31, 32, 33, 34], 4: [41, 42, 43, 44, 45],
            5: [51, 52, 53, 54, 55], 6: [61, 62, 63, 64], 7: [71, 72, 73, 74, 75], 8: [81, 82, 83, 84, 85]
        };

        let focusState = { row: 0, beat: 0 };
        let scoreData = [new Array(beatsPerMeasure).fill(0)]; // 預設一個小節（4拍）
        let selectedNoteId = null; // 當前選中的音符 ID

        // 定義循環輸入規則
        const NOTE_CYCLES = {
            21: [21, 22, 23],
            31: [31, 32, 33, 34],
            41: [41, 42, 43, 44, 45],
            51: [51, 52, 53, 54],
            61: [61, 62, 63, 64],
            71: [71, 72, 73, 74, 75],
            81: [81, 82, 83, 84]
        };

        function initApp() {
            renderRows();
            initRandomToggles();
            initNoteSelector();
            bpmSlider.oninput = (e) => { bpmValue.textContent = e.target.value; };
            addRowBtn.onclick = () => { if (scoreData.length < maxRows) { scoreData.push(new Array(beatsPerMeasure).fill(0)); renderRows(); } };
            playBtn.onclick = () => { 
                isLoopMode = false; 
                togglePlayback(); 
            };
            loopBtn.onclick = () => { 
                isLoopMode = true; 
                togglePlayback(); 
            };
            randomFillBtn.onclick = handleRandomFill;
            metronomeCheckbox.onchange = (e) => { isMetronomeEnabled = e.target.checked; };
        }

        function updateButtonStates() {
            // 只有在播放时才设置互斥状态
            if (isPlaying) {
                if (isLoopMode) {
                    playBtn.classList.add('disabled');
                    loopBtn.classList.remove('disabled');
                } else {
                    playBtn.classList.remove('disabled');
                    loopBtn.classList.add('disabled');
                }
            } else {
                // 停止时，两个按钮都亮
                playBtn.classList.remove('disabled');
                loopBtn.classList.remove('disabled');
            }
        }

        function initNoteSelector() {
            const noteSelector = document.getElementById('noteSelector');
            noteSelector.querySelectorAll('.note-chip').forEach(chip => {
                chip.onclick = () => {
                    // 移除所有 active 狀態
                    noteSelector.querySelectorAll('.note-chip').forEach(c => c.classList.remove('active'));
                    // 設置當前選中的 chip 為 active
                    chip.classList.add('active');
                    // 保存選中的音符 ID
                    selectedNoteId = parseInt(chip.getAttribute('data-id'));
                };
            });
        }

        function initRandomToggles() {
            randomOptionsContainer.querySelectorAll('.random-chip').forEach(chip => { chip.onclick = () => { chip.classList.toggle('selected'); }; });
        }

        function handleRandomFill() {
            const selectedSeries = Array.from(randomOptionsContainer.querySelectorAll('.random-chip.selected')).map(chip => chip.getAttribute('data-value'));
            if (selectedSeries.length === 0) return;
            let pool = []; selectedSeries.forEach(s => { pool = pool.concat(SERIES_MAP[s]); });
            scoreData.forEach((rowData) => { for (let i = 0; i < rowData.length; i++) { rowData[i] = pool[Math.floor(Math.random() * pool.length)]; } });
            renderRows();
        }

        async function togglePlayback() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            if (!isPlaying) {
                isPlaying = true; isCountingIn = true; countInStep = 0; currentGlobalStep = 0; 
                // 減少初始延遲，使用更小的值以減少首次播放延遲
                nextNoteTime = audioCtx.currentTime + 0.05;
                const overlay = document.getElementById('countInOverlay');
                if (overlay) overlay.style.display = 'flex';
                timerWorker.postMessage("start");
                if (isLoopMode) {
                    loopBtn.classList.add('playing'); loopBtn.textContent = "停止";
                } else {
                    playBtn.classList.add('playing'); playBtn.textContent = "停止";
                }
                updateButtonStates(); // 更新按钮状态，使另一个按钮灰阶
            } else { stopPlayback(); }
        }

        function stopPlayback() {
            isPlaying = false; isCountingIn = false;
            timerWorker.postMessage("stop");
            playBtn.classList.remove('playing'); playBtn.textContent = "播放";
            loopBtn.classList.remove('playing'); loopBtn.textContent = "循環";
            const overlay = document.getElementById('countInOverlay');
            if (overlay) overlay.style.display = 'none';
            clearPlaybackUI(); resetRowStyles();
            updateButtonStates();
        }

        function clearPlaybackUI() { document.querySelectorAll('.beat-box').forEach(el => el.classList.remove('playing-now')); }
        function resetRowStyles() { document.querySelectorAll('.editor-row').forEach(row => { row.classList.remove('playing-row'); }); }

        timerWorker.onmessage = (e) => {
            if (e.data === "tick") {
                if (!isPlaying) return;
                const bpm = parseInt(bpmSlider.value), beatDur = 60.0 / bpm;
                // 增加調度提前時間到 0.2 秒，確保高 BPM 時也能及時調度
                const scheduleAheadTime = 0.2;
                while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                    if (isCountingIn) {
                        if (countInStep < 4) { scheduleCountIn(countInStep, nextNoteTime); countInStep++; }
                        else { isCountingIn = false; updateCountInUI(null); processSequenceStep(beatDur); }
                    } else { processSequenceStep(beatDur); }
                    nextNoteTime += beatDur; 
                }
            }
        };

        function processSequenceStep(dur) {
            // 計算總步數：所有句段的所有拍數總和
            const totalStepsInSequence = scoreData.reduce((sum, rowData) => sum + rowData.length, 0);
            
            // 如果是循環模式且到達末尾，重置到開始
            if (currentGlobalStep >= totalStepsInSequence) {
                if (isLoopMode) {
                    currentGlobalStep = 0;
                } else {
                    stopPlayback(); 
                    return;
                }
            }
            
            // 找到當前步數對應的句段和拍數
            let stepCount = 0;
            let r = 0, b = 0;
            for (let i = 0; i < scoreData.length; i++) {
                if (currentGlobalStep < stepCount + scoreData[i].length) {
                    r = i;
                    b = currentGlobalStep - stepCount;
                    break;
                }
                stepCount += scoreData[i].length;
            }
            
            scheduleStep(r, b, nextNoteTime, dur); currentGlobalStep++;
        }

        function scheduleCountIn(step, time) {
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time);
            gain.gain.setValueAtTime(0.4, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(time); osc.stop(time + 0.1);
            const countText = (4 - step).toString();
            const delay = (time - audioCtx.currentTime) * 1000;
            setTimeout(() => { if (isCountingIn && isPlaying) updateCountInUI(countText); }, Math.max(0, delay));
        }

        function updateCountInUI(text) {
            const overlay = document.getElementById('countInOverlay'); if (!overlay) return;
            if (text === null) overlay.style.display = 'none'; else { overlay.style.display = 'flex'; overlay.textContent = text; }
        }

        function playSound(time, freq, volume = 0.3, soundType = 'snap', isAccent = false) {
            // 確保時間不會是過去時間，避免延遲
            const scheduleTime = Math.max(time, audioCtx.currentTime);
            const finalVol = isAccent ? volume * 1.6 : volume, finalFreq = isAccent ? freq * 1.2 : freq;
            if (soundType === 'noise') {
                const bufferSize = audioCtx.sampleRate * 0.1, buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate), data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = buffer;
                const gainNode = audioCtx.createGain(), noiseFilter = audioCtx.createBiquadFilter();
                noiseFilter.type = 'highpass'; noiseFilter.frequency.value = finalFreq * 3;
                noiseSource.connect(noiseFilter); noiseFilter.connect(gainNode);
                gainNode.gain.setValueAtTime(finalVol * 0.4, scheduleTime); gainNode.gain.exponentialRampToValueAtTime(0.001, scheduleTime + 0.05);
                noiseSource.start(scheduleTime); noiseSource.stop(scheduleTime + 0.08); gainNode.connect(audioCtx.destination); return;
            }
            const osc = audioCtx.createOscillator(), gainNode = audioCtx.createGain();
            osc.type = 'square'; osc.frequency.setValueAtTime(finalFreq * 2, scheduleTime);
            gainNode.gain.setValueAtTime(finalVol * 0.5, scheduleTime); gainNode.gain.exponentialRampToValueAtTime(0.001, scheduleTime + 0.05);
            osc.connect(gainNode); gainNode.connect(audioCtx.destination); osc.start(scheduleTime); osc.stop(scheduleTime + 0.08);
        }

        function playMetronomeTick(time) {
            // 播放叮聲作為拍子提示（類似倒數的聲音）
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time);
            gain.gain.setValueAtTime(0.3, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.08);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(time); osc.stop(time + 0.08);
        }

        // 檢查音符類型是否在第一個位置（p16[0]）有聲音
        function hasSoundAtFirstPosition(type) {
            if (type === 0 || type === 12) return false; // 無聲
            if (type === 11) return true; // 4分音符，在第一個位置
            if (type === 21 || type === 23) return true; // 8分音符，在第一個位置
            if (type === 22) return false; // 8分音符，在第二個位置
            if (type === 31) return true; // 16分單點，在第一個位置
            if (type >= 32 && type <= 34) return false; // 16分單點，在其他位置
            // 16分雙點
            if (type === 41 || type === 44) return true; // [0,1] 或 [0,3]
            if (type === 42 || type === 43 || type === 45) return false; // 不在第一個位置
            // 16分三點
            if (type === 51 || type === 52 || type === 53 || type === 55) return true; // 包含第一個位置
            if (type === 54) return false; // [1,2,3]，不在第一個位置
            // 16分單重音、雙重音、三重音：所有位置都有聲音，所以第一個位置也有
            if (type >= 61 && type <= 85) return true;
            return false;
        }

        function scheduleStep(r, b, time, dur) {
            const type = scoreData[r][b]; updateUI(r, b, time);
            
            // 如果啟用了拍子提示，且是小節第一拍，播放叮聲
            const shouldPlayMetronome = isMetronomeEnabled && (b % beatsPerMeasure === 0);
            const skipFirstPosition = shouldPlayMetronome && hasSoundAtFirstPosition(type);
            
            if (shouldPlayMetronome) {
                playMetronomeTick(time);
            }
            
            if (type === 0 || type === 12) return;
            const baseFreq = 220, p16 = [0, 0.25, 0.5, 0.75], cS = soundSelect.value, cAS = accentSoundSelect.value;
            const play = (t, isAcc = false) => { playSound(t, baseFreq, 0.3, isAcc ? cAS : cS, isAcc); };
            
            if (type === 11) {
                if (!skipFirstPosition) play(time);
            } else if (type === 21) {
                if (!skipFirstPosition) play(time);
            } else if (type === 22) {
                play(time + dur * 0.5); // 後半拍正常播放
            } else if (type === 23) {
                if (!skipFirstPosition) play(time); // 前半拍：如果第一個位置有聲音且啟用拍子提示，則跳過
                play(time + dur * 0.5); // 後半拍正常播放
            } else if (type >= 31 && type <= 34) {
                if (!skipFirstPosition || type !== 31) play(time + dur * p16[type - 31]);
            } else if (type >= 41 && type <= 45) {
                const m = { 41:[0,1], 42:[1,2], 43:[2,3], 44:[0,3], 45:[1,3] };
                m[type].forEach(idx => {
                    // 如果跳過第一個位置且當前是第一個位置，則跳過
                    if (!(skipFirstPosition && idx === 0)) {
                        play(time + dur * p16[idx]);
                    }
                });
            } else if (type >= 51 && type <= 55) {
                const m = { 51:[0,2,3], 52:[0,1,2], 53:[0,1,3], 54:[1,2,3], 55:[0,1,2,3] };
                m[type].forEach(idx => {
                    if (!(skipFirstPosition && idx === 0)) {
                        play(time + dur * p16[idx]);
                    }
                });
            } else if (type >= 61 && type <= 64) {
                const aI = type - 61;
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, i === aI);
                    }
                });
            } else if (type >= 71 && type <= 75) {
                const m = { 71:[0,1], 72:[1,2], 73:[2,3], 74:[0,3], 75:[1,3] };
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, m[type].includes(i));
                    }
                });
            } else if (type >= 81 && type <= 85) {
                const m = { 81:[0,2,3], 82:[0,1,2], 83:[0,1,3], 84:[1,2,3], 85:[0,1,2,3] };
                p16.forEach((off, i) => {
                    if (!(skipFirstPosition && i === 0)) {
                        play(time + dur * off, m[type].includes(i));
                    }
                });
            }
        }

        function updateUI(r, b, time) {
            // 确保时间不会太早，使用当前音频上下文时间作为基准
            const scheduleTime = Math.max(time, audioCtx.currentTime);
            const delay = (scheduleTime - audioCtx.currentTime) * 1000;
            
            // 使用 requestAnimationFrame 来确保更精确的时间同步
            if (delay <= 0) {
                // 如果时间已过或非常接近，立即更新
                if (!isPlaying || isCountingIn) return;
                document.querySelectorAll('.editor-row').forEach((row, idx) => { if (idx === r) row.classList.add('playing-row'); else row.classList.remove('playing-row'); });
                clearPlaybackUI(); 
                const el = document.getElementById(`beat-${r}-${b}`); 
                if (el) el.classList.add('playing-now');
            } else {
                // 使用 setTimeout，但确保延迟计算准确
                setTimeout(() => {
                    if (!isPlaying || isCountingIn) return;
                    document.querySelectorAll('.editor-row').forEach((row, idx) => { if (idx === r) row.classList.add('playing-row'); else row.classList.remove('playing-row'); });
                    clearPlaybackUI(); 
                    const el = document.getElementById(`beat-${r}-${b}`); 
                    if (el) el.classList.add('playing-now');
                }, Math.max(0, Math.round(delay)));
            }
        }

        function drawNoteHead(ctx, x, y, color = '#1e293b') { ctx.save(); ctx.fillStyle = color; ctx.translate(x, y); ctx.rotate(-0.25); ctx.beginPath(); ctx.ellipse(0, 0, 5, 3.5, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawStem(ctx, x, yT, yB, color = '#1e293b', w = 1.5) { ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = w; ctx.beginPath(); ctx.moveTo(x, yT); ctx.lineTo(x, yB); ctx.stroke(); ctx.restore(); }
        function drawQuarterRest(ctx, x, y) { ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x - 4, y - 10); ctx.lineTo(x + 2, y - 4); ctx.lineTo(x - 4, y + 2); ctx.lineTo(x + 2, y + 8); ctx.bezierCurveTo(x + 2, y + 11, x - 1, y + 12, x - 4, y + 10); ctx.stroke(); ctx.restore(); }
        function drawAccent(ctx, x, y) { ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x - 4, y - 3); ctx.lineTo(x + 3, y); ctx.lineTo(x - 4, y + 3); ctx.stroke(); ctx.restore(); }

        function drawNote(ctx, type) {
            ctx.clearRect(0, 0, 80, 80); if (type === 0) return;
            const bY = 55, sT = 22, center = 40, sSB = 38;
            if (type === 11) { drawNoteHead(ctx, center - 4, bY); drawStem(ctx, center + 0.5, sT, bY); }
            else if (type === 12) { drawQuarterRest(ctx, center, 40); }
            else if (type >= 21 && type <= 23) { 
                const p1 = 25, p2 = 55; ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(p1+4.5, sT+2); ctx.lineTo(p2+4.5, sT+2); ctx.stroke(); ctx.restore();
                if (type === 21 || type === 23) { drawNoteHead(ctx, p1, bY); drawStem(ctx, p1+4.5, sT, bY, '#1e293b', 2); } else { drawStem(ctx, p1+4.5, sT, sSB, '#1e293b', 1.5); }
                if (type === 22 || type === 23) { drawNoteHead(ctx, p2, bY); drawStem(ctx, p2+4.5, sT, bY, '#1e293b', 2); } else { drawStem(ctx, p2+4.5, sT, sSB, '#1e293b', 1.5); }
            } else if (type >= 31) { 
                const pos = [18, 32, 46, 60]; let act = [], acc = [];
                if (type >= 31 && type <= 34) act = [type - 31];
                else if (type === 41) act = [0, 1]; else if (type === 42) act = [1, 2]; else if (type === 43) act = [2, 3]; else if (type === 44) act = [0, 3]; else if (type === 45) act = [1, 3];
                else if (type === 51) act = [0, 2, 3]; else if (type === 52) act = [0, 1, 2]; else if (type === 53) act = [0, 1, 3]; else if (type === 54) act = [1, 2, 3]; else if (type === 55) act = [0, 1, 2, 3];
                else if (type >= 61 && type <= 64) { act = [0, 1, 2, 3]; acc = [type - 61]; }
                else if (type >= 71 && type <= 75) { act = [0, 1, 2, 3]; if (type === 71) acc = [0, 1]; else if (type === 72) acc = [1, 2]; else if (type === 73) acc = [2, 3]; else if (type === 74) acc = [0, 3]; else if (type === 75) acc = [1, 3]; }
                else if (type >= 81 && type <= 85) { act = [0, 1, 2, 3]; if (type === 81) acc = [0, 2, 3]; else if (type === 82) acc = [0, 1, 2]; else if (type === 83) acc = [0, 1, 3]; else if (type === 84) acc = [1, 2, 3]; else if (type === 85) acc = [0, 1, 2, 3]; }
                ctx.save(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(pos[0]+4.5, sT); ctx.lineTo(pos[3]+4.5, sT); ctx.stroke(); ctx.beginPath(); ctx.moveTo(pos[0]+4.5, sT+6); ctx.lineTo(pos[3]+4.5, sT+6); ctx.stroke(); ctx.restore();
                pos.forEach((x, i) => { if (act.includes(i)) { drawNoteHead(ctx, x, bY); drawStem(ctx, x+4.5, sT, bY, '#1e293b', 1.5); if (acc.includes(i)) drawAccent(ctx, x + 4, sT - 8); } else { drawStem(ctx, x+4.5, sT, sSB, '#1e293b', 1.2); } });
            }
        }

        function renderRows() {
            rowsContainer.innerHTML = '';
            scoreData.forEach((rowData, rI) => {
                const row = document.createElement('div'); row.className = 'editor-row';
                const head = document.createElement('div'); head.className = 'row-header';
                const lab = document.createElement('div'); lab.className = 'row-label'; lab.textContent = `句段 ${rI+1}`;
                head.appendChild(lab);
                
                // 添加增加/刪除小節的按鈕容器到 row-header
                const measureButtonsContainer = document.createElement('div');
                measureButtonsContainer.className = 'measure-buttons';
                
                // 添加增加小節的按鈕
                if (rowData.length < maxMeasures * beatsPerMeasure) {
                    const addMeasureBtn = document.createElement('button');
                    addMeasureBtn.className = 'btn-add-measure';
                    addMeasureBtn.textContent = '+';
                    addMeasureBtn.title = '增加小節';
                    addMeasureBtn.onclick = () => {
                        // 增加一個小節（4拍）
                        for (let i = 0; i < beatsPerMeasure; i++) {
                            scoreData[rI].push(0);
                        }
                        renderRows();
                    };
                    measureButtonsContainer.appendChild(addMeasureBtn);
                }
                
                // 添加刪除小節的按鈕（當小節數大於1時顯示）
                const currentMeasureCount = Math.ceil(rowData.length / beatsPerMeasure);
                if (currentMeasureCount > 1) {
                    const removeMeasureBtn = document.createElement('button');
                    removeMeasureBtn.className = 'btn-remove-measure';
                    removeMeasureBtn.textContent = '−';
                    removeMeasureBtn.title = '刪除小節';
                    removeMeasureBtn.onclick = () => {
                        // 刪除最後一個小節（4拍）
                        const removeCount = Math.min(beatsPerMeasure, rowData.length);
                        scoreData[rI].splice(rowData.length - removeCount, removeCount);
                        // 確保至少保留一個小節
                        if (scoreData[rI].length === 0) {
                            for (let i = 0; i < beatsPerMeasure; i++) {
                                scoreData[rI].push(0);
                            }
                        }
                        // 調整焦點位置，確保不超出範圍
                        if (focusState.row === rI && focusState.beat >= scoreData[rI].length) {
                            focusState.beat = Math.max(0, scoreData[rI].length - 1);
                        }
                        renderRows();
                    };
                    measureButtonsContainer.appendChild(removeMeasureBtn);
                }
                
                if (measureButtonsContainer.children.length > 0) {
                    head.appendChild(measureButtonsContainer);
                }
                
                if (scoreData.length > 1) { const rm = document.createElement('button'); rm.className = 'btn-remove'; rm.textContent = '×'; rm.onclick = () => { scoreData.splice(rI,1); renderRows(); }; head.appendChild(rm); }
                row.appendChild(head);
                const strip = document.createElement('div'); strip.className = 'editor-strip';
                
                // 動態渲染小節，根據 rowData 的長度
                const measureCount = Math.ceil(rowData.length / beatsPerMeasure);
                for (let m = 0; m < measureCount; m++) {
                    const meas = document.createElement('div'); meas.className = 'measure';
                    const inf = document.createElement('div'); inf.className = 'beat-info'; inf.textContent = `小節 ${m+1}`; meas.appendChild(inf);
                    const bR = document.createElement('div'); bR.className = 'measure-beats';
                    for (let b = 0; b < beatsPerMeasure; b++) {
                        const bIdx = m * beatsPerMeasure + b;
                        const box = document.createElement('div');
                        box.className = `beat-box`; if(rI===focusState.row && bIdx===focusState.beat) box.classList.add('active');
                        box.id = `beat-${rI}-${bIdx}`;
                        if (bIdx < rowData.length) {
                            // 如果數據存在，顯示音符
                            if (rI === 0 && bIdx === 0) { const over = document.createElement('div'); over.id = 'countInOverlay'; box.appendChild(over); }
                            const can = document.createElement('canvas'); can.width = 80; can.height = 80;
                            box.appendChild(can); box.onclick = () => setFocus(rI, bIdx); 
                            requestAnimationFrame(() => drawNote(can.getContext('2d'), rowData[bIdx]));
                        } else {
                            // 如果數據不存在，顯示空白格子（用於最後一個不完整的小節）
                            box.style.opacity = '0.3';
                            box.style.pointerEvents = 'none';
                        }
                        bR.appendChild(box);
                    }
                    meas.appendChild(bR); strip.appendChild(meas);
                }
                
                row.appendChild(strip); rowsContainer.appendChild(row);
            });
        }

        function setFocus(r, b) { 
            r = (r + scoreData.length) % scoreData.length; 
            if (!scoreData[r]) return;
            const maxBeat = scoreData[r].length;
            b = (b + maxBeat) % maxBeat; 
            
            // 如果有選中的音符，執行循環輸入
            if (selectedNoteId !== null) {
                const currentValue = scoreData[r][b];
                const cycle = NOTE_CYCLES[selectedNoteId];
                
                if (cycle) {
                    // 如果當前值在循環範圍內，找到下一個值
                    const currentIndex = cycle.indexOf(currentValue);
                    if (currentIndex >= 0) {
                        // 循環到下一個值
                        const nextIndex = (currentIndex + 1) % cycle.length;
                        scoreData[r][b] = cycle[nextIndex];
                    } else {
                        // 如果當前值不在循環範圍內，設置為循環的第一個值
                        scoreData[r][b] = cycle[0];
                    }
                } else {
                    // 如果沒有循環規則，直接設置為選中的值
                    scoreData[r][b] = selectedNoteId;
                }
            }
            
            focusState = { row: r, beat: b }; 
            renderRows(); 
        }

        window.onkeydown = (e) => {
            if (e.code === 'Space') { e.preventDefault(); togglePlayback(); return; }
            if (!scoreData[focusState.row] || focusState.beat >= scoreData[focusState.row].length) return;
            const cur = scoreData[focusState.row][focusState.beat]; let val = -1;
            if (e.key === '1') val = (cur === 11) ? 12 : 11;
            else if (e.key === '2') { if (cur === 21) val = 22; else if (cur === 22) val = 23; else val = 21; }
            else if (e.key === '3') { if (cur >= 31 && cur < 34) val = cur + 1; else val = 31; }
            else if (e.key === '4') { if (cur >= 41 && cur < 45) val = cur + 1; else val = 41; }
            else if (e.key === '5') { if (cur >= 51 && cur < 55) val = cur + 1; else val = 51; }
            else if (e.key === '6') { if (cur >= 61 && cur < 64) val = cur + 1; else val = 61; }
            else if (e.key === '7') { if (cur >= 71 && cur < 75) val = cur + 1; else val = 71; }
            else if (e.key === '8') { if (cur >= 81 && cur < 85) val = cur + 1; else val = 81; }
            else if (e.key === 'Escape' || e.key === 'Backspace') val = 0;
            if (val !== -1) { scoreData[focusState.row][focusState.beat] = val; renderRows(); }
            if (e.key === 'ArrowRight') { e.preventDefault(); setFocus(focusState.row, focusState.beat + 1); }
            if (e.key === 'ArrowLeft') { e.preventDefault(); setFocus(focusState.row, focusState.beat - 1); }
            if (e.key === 'ArrowUp') { e.preventDefault(); setFocus(focusState.row - 1, focusState.beat); }
            if (e.key === 'ArrowDown') { e.preventDefault(); setFocus(focusState.row + 1, focusState.beat); }
            // 確保焦點不超出當前句段的範圍
            if (scoreData[focusState.row] && focusState.beat >= scoreData[focusState.row].length) {
                focusState.beat = scoreData[focusState.row].length - 1;
                renderRows();
            }
        };

        initApp();
    </script>
</body>
</html>